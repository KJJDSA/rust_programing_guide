fn main() {
    let x = 5;

    // 섀도잉 : 기존의 값을 잠시 가린다. 섀도잉은 스코프가 끝나면 걷혀진다. 
    // 즉 같은 스코프에서 변한 것은 영구적으로 변한 것이라 봐야한다. 
    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}"); // 12
    }

    println!("The value of x is: {x}"); // 다시 6으로 돌아왔다. 

    /*  ⭐️ 섀도잉은 이처럼 타입과 값을 그 스코프에 한정해 바꿀수 있다. 
    이는 휴먼에러를 일으킬 수 있는 단초가 된다. 같은 타입의 값으로 mut 처럼 가변성있게 사용해버리면 
    사람의 머리가 견디질 못할 것이다. 
    고로 커뮤니티에서는 짧은 타입변환 시에만 섀도잉을 쓰라고 권장한다. 타입이 변환되면 컴파일러가 100% 오류를 잡기 때문.
     */
}
